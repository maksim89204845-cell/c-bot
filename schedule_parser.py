import requests
import PyPDF2
import io
import re
import logging
from datetime import datetime, timedelta
from typing import List, Dict, Optional

class ScheduleParser:
    def __init__(self, google_drive_url: str):
        self.google_drive_url = google_drive_url
        self.schedule_data = {}
        self.last_update = None
        
    def download_pdf(self) -> Optional[bytes]:
        """–°–∫–∞—á–∏–≤–∞–µ—Ç PDF —Å Google Drive"""
        try:
            logging.info("–ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ PDF...")
            
            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –ø—Ä—è–º–æ–≥–æ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
            file_id = self.google_drive_url.split('/d/')[1].split('/')[0]
            direct_url = f"https://drive.google.com/uc?export=download&id={file_id}"
            
            logging.info(f"–°–∫–∞—á–∏–≤–∞—é —Å URL: {direct_url}")
            
            response = requests.get(direct_url, timeout=30)
            response.raise_for_status()
            
            logging.info(f"PDF —É—Å–ø–µ—à–Ω–æ —Å–∫–∞—á–∞–Ω, —Ä–∞–∑–º–µ—Ä: {len(response.content)} –±–∞–π—Ç")
            return response.content
            
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è PDF: {e}")
            return None
    
    def extract_text_from_pdf(self, pdf_content: bytes) -> str:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–µ–∫—Å—Ç –∏–∑ PDF –ø–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞–º –∏ –Ω–∞—Ö–æ–¥–∏—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å –≥—Ä—É–ø–ø–æ–π 302–§"""
        try:
            pdf_file = io.BytesIO(pdf_content)
            reader = PyPDF2.PdfReader(pdf_file)
            
            logging.info(f"PDF —Å–æ–¥–µ—Ä–∂–∏—Ç {len(reader.pages)} —Å—Ç—Ä–∞–Ω–∏—Ü")
            
            # –ò—â–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å –≥—Ä—É–ø–ø–æ–π 302–§
            target_page = None
            for page_num in range(len(reader.pages)):
                page = reader.pages[page_num]
                page_text = page.extract_text()
                
                logging.info(f"–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page_num + 1}: –∏—â—É –≥—Ä—É–ø–ø—É 302–§...")
                
                if "302–§" in page_text:
                    logging.info(f"‚úÖ –ì—Ä—É–ø–ø–∞ 302–§ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ {page_num + 1}")
                    target_page = page_num
                    break
                else:
                    logging.info(f"‚ùå –ì—Ä—É–ø–ø–∞ 302–§ –ù–ï –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ {page_num + 1}")
            
            if target_page is None:
                logging.error("‚ùå –ì—Ä—É–ø–ø–∞ 302–§ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∏ –Ω–∞ –æ–¥–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ!")
                return ""
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç —Ç–æ–ª—å–∫–æ —Å –Ω—É–∂–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
            page = reader.pages[target_page]
            text = page.extract_text()
            
            logging.info(f"–ò–∑–≤–ª–µ—á–µ–Ω —Ç–µ–∫—Å—Ç —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã {target_page + 1}, –¥–ª–∏–Ω–∞: {len(text)} —Å–∏–º–≤–æ–ª–æ–≤")
            logging.info(f"–ü–µ—Ä–≤—ã–µ 500 —Å–∏–º–≤–æ–ª–æ–≤: {text[:500]}")
            
            return text
            
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ —Ç–µ–∫—Å—Ç–∞ –∏–∑ PDF: {str(e)}")
            return ""
    
    def parse_schedule(self, text: str) -> Dict:
        """–ü–∞—Ä—Å–∏—Ç —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∏–∑ —Ç–µ–∫—Å—Ç–∞"""
        schedule = {}
        
        # –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        logging.info(f"=== –û–¢–õ–ê–î–ö–ê –ü–ê–†–°–ò–ù–ì–ê ===")
        logging.info(f"–î–ª–∏–Ω–∞ —Ç–µ–∫—Å—Ç–∞: {len(text)}")
        logging.info(f"–ü–µ—Ä–≤—ã–µ 500 —Å–∏–º–≤–æ–ª–æ–≤: {text[:500]}")
        
        # –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ —Å—Ç—Ä–æ–∫–∏
        lines = text.split('\n')
        
        current_date = None
        current_time = None
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            # –ò—â–µ–º –¥–∞—Ç—É (—Ñ–æ—Ä–º–∞—Ç: DD.MM.YYYY)
            date_match = re.search(r'(\d{2}\.\d{2}\.\d{4})', line)
            if date_match:
                current_date = date_match.group(1)
                schedule[current_date] = {}
                logging.info(f"–ù–∞–π–¥–µ–Ω–∞ –¥–∞—Ç–∞: {current_date}")
                continue
            
            # –ò—â–µ–º –≤—Ä–µ–º—è (—Ñ–æ—Ä–º–∞—Ç: HH:MM-HH:MM)
            time_match = re.search(r'(\d{2}:\d{2})-(\d{2}:\d{2})', line)
            if time_match:
                current_time = f"{time_match.group(1)}-{time_match.group(2)}"
                if current_date and current_time:
                    schedule[current_date][current_time] = {
                        'subject': '',
                        'instructor': '',
                        'auditorium': ''
                    }
                    logging.info(f"–ù–∞–π–¥–µ–Ω–æ –≤—Ä–µ–º—è: {current_time} –¥–ª—è –¥–∞—Ç—ã {current_date}")
                continue
            
            # –ò—â–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–Ω—è—Ç–∏–∏ –¥–ª—è –≥—Ä—É–ø–ø—ã 302–§
            if current_date and current_time and '302' in line:
                logging.info(f"–ù–∞–π–¥–µ–Ω–∞ —Å—Ç—Ä–æ–∫–∞ —Å 302: {line}")
                # –ò–∑–≤–ª–µ–∫–∞–µ–º –ø—Ä–µ–¥–º–µ—Ç, –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è –∏ –∞—É–¥–∏—Ç–æ—Ä–∏—é
                parts = line.split()
                if len(parts) >= 3:
                    schedule[current_date][current_time] = {
                        'subject': ' '.join(parts[:-2]),
                        'instructor': parts[-2],
                        'auditorium': parts[-1]
                    }
                    logging.info(f"–ò–∑–≤–ª–µ—á–µ–Ω–æ: –ø—Ä–µ–¥–º–µ—Ç={parts[:-2]}, –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å={parts[-2]}, –∞—É–¥–∏—Ç–æ—Ä–∏—è={parts[-1]}")
        
        logging.info(f"–ò—Ç–æ–≥–æ–≤–æ–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ: {schedule}")
        logging.info(f"=== –ö–û–ù–ï–¶ –û–¢–õ–ê–î–ö–ò ===")
        return schedule
    
    def get_schedule_for_date(self, target_date: str) -> Dict:
        """–ü–æ–ª—É—á–∞–µ—Ç —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –¥–∞—Ç—É"""
        if not self.schedule_data:
            self.update_schedule()
        
        return self.schedule_data.get(target_date, {})
    
    def get_schedule_for_tomorrow(self) -> Dict:
        """–ü–æ–ª—É—á–∞–µ—Ç —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞"""
        tomorrow = (datetime.now() + timedelta(days=1)).strftime('%d.%m.%Y')
        return self.get_schedule_for_date(tomorrow)
    
    def get_schedule_for_week(self) -> Dict:
        """–ü–æ–ª—É—á–∞–µ—Ç —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –Ω–µ–¥–µ–ª—é"""
        if not self.schedule_data:
            self.update_schedule()
        
        return self.schedule_data
    
    def update_schedule(self) -> bool:
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ"""
        try:
            pdf_content = self.download_pdf()
            if pdf_content:
                text = self.extract_text_from_pdf(pdf_content)
                self.schedule_data = self.parse_schedule(text)
                self.last_update = datetime.now()
                return True
            return False
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
            return False
    
    def format_schedule_message(self, schedule: Dict, date: str = None) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram"""
        if not schedule:
            return "–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∏–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ."
        
        if date:
            # –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –¥–∞—Ç—É
            message = f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {date}:\n\n"
            for time, lesson in schedule.items():
                if lesson.get('subject'):
                    message += f"üïê {time}\n"
                    message += f"üìö {lesson['subject']}\n"
                    message += f"üë®‚Äçüè´ {lesson['instructor']}\n"
                    message += f"üè¢ {lesson['auditorium']}\n"
                    message += "‚îÄ" * 30 + "\n"
                else:
                    message += f"üïê {time} - –ê—É–¥–∏—Ç.\n"
                    message += "‚îÄ" * 30 + "\n"
        else:
            # –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –Ω–µ–¥–µ–ª—é
            message = "üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –Ω–µ–¥–µ–ª—é:\n\n"
            for date, day_schedule in schedule.items():
                message += f"üìÜ {date}\n"
                for time, lesson in day_schedule.items():
                    if lesson.get('subject'):
                        message += f"üïê {time} - {lesson['subject']} ({lesson['instructor']}, {lesson['auditorium']})\n"
                    else:
                        message += f"üïê {time} - –ê—É–¥–∏—Ç.\n"
                message += "‚îÄ" * 30 + "\n"
        
        if self.last_update:
            message += f"\nüîÑ –ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {self.last_update.strftime('%d.%m.%Y %H:%M')}"
        
        return message
    
    def split_long_message(self, message: str, max_length: int = 4000) -> List[str]:
        """–†–∞–∑–±–∏–≤–∞–µ—Ç –¥–ª–∏–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —á–∞—Å—Ç–∏"""
        if len(message) <= max_length:
            return [message]
        
        parts = []
        lines = message.split('\n')
        current_part = ""
        
        for line in lines:
            if len(current_part + line + '\n') > max_length:
                if current_part:
                    parts.append(current_part.strip())
                    current_part = line + '\n'
                else:
                    # –û–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–∞—è
                    parts.append(line[:max_length-3] + "...")
            else:
                current_part += line + '\n'
        
        if current_part:
            parts.append(current_part.strip())
        
        return parts
    
    def format_week_schedule_messages(self, schedule: Dict) -> List[str]:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –Ω–µ–¥–µ–ª—é —Å —Ä–∞–∑–±–∏–≤–∫–æ–π –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        if not schedule:
            return ["üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –Ω–µ–¥–µ–ª—é –Ω–µ –Ω–∞–π–¥–µ–Ω–æ."]
        
        # –°–æ–∑–¥–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –¥–Ω—è
        messages = []
        
        for date, day_schedule in schedule.items():
            day_message = f"üìÖ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {date}:\n\n"
            
            for time, lesson in day_schedule.items():
                if lesson.get('subject'):
                    day_message += f"üïê {time}\n"
                    day_message += f"üìö {lesson['subject']}\n"
                    day_message += f"üë®‚Äçüè´ {lesson['instructor']}\n"
                    day_message += f"üè¢ {lesson['auditorium']}\n"
                    day_message += "‚îÄ" * 30 + "\n"
                else:
                    day_message += f"üïê {time} - –ê—É–¥–∏—Ç.\n"
                    day_message += "‚îÄ" * 30 + "\n"
            
            if self.last_update:
                day_message += f"\nüîÑ –û–±–Ω–æ–≤–ª–µ–Ω–æ: {self.last_update.strftime('%d.%m.%Y %H:%M')}"
            
            messages.append(day_message)
        
        return messages
